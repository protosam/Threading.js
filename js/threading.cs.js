var Threading=function(makename){this.failreason=null;if(typeof window=="undefined"){console.log('Threading.js was made to work with the "window" variable. If you are using nodejs, you will need to seek something for Workers in npm.');this.failreason="Not ran in a browser.";return undefined}if(typeof Worker=="undefined"){console.log("Worker is no supported by your JS engine. This may be due to an outdated browser.");this.failreason="Worker not available.";return undefined}if(typeof Proxy=="undefined"){console.log("Proxy is not supported by your JS engine. This may be due to an outdated browser.");
this.failreason="Proxy not available.";return undefined}var wid="worker"+(new Date).getTime();if(typeof makename==typeof function(){})window[wid]=(new Worker(this.buildblob_from_function(makename))).auto();else if(typeof makename=="undefined")window[wid]=(new Worker(this.buildblob_from_class())).auto();else{console.log("Threading.js was provided an unsupported input type. If you are trying to refernce a JS file as your worker, use the normal Worker() function. Threading.js does not support that because of problems between browsers and file location issues.");
this.failreason="Threading.js was provided an unsupported input type.";return undefined}window[wid]["id"]=wid;return new Proxy({id:wid},{get:function(target,name){if(!(name in window[target["id"]])){window[target["id"]]["anonMethodName"]=name;return window[target["id"]]["sendToWorker"]}return window[target["id"]][name]},set:function(target,name,value){console.log("Setting things will not work in Threading.js yet.")}})};
Threading.prototype.helper_functions=function(){var anonMethodName=null;self.addEventListener("message",function(event){data=JSON.parse(event.data);if(typeof this[data.method]!="undefined")this[data.method].apply(this,data.args)},false);var root=new Proxy({},{get:function(target,name){anonMethodName=name;return function(){callback_details=JSON.stringify({method:anonMethodName,args:Array.from(arguments)});postMessage(callback_details);return this}},set:function(target,name,value){console.log("Setting things will not work in Threading.js yet.")}})};
Threading.prototype.blobify=function(codeout){var blob=new Blob([codeout]);var bloburl=window.URL.createObjectURL(blob);return bloburl};Threading.prototype.blobfixer=function(method){if(typeof method==typeof function(){})var codeout=method.toString();else var codeout=this[method].toString();codeout=codeout.substring(codeout.indexOf("{")+1);codeout=codeout.substring(0,codeout.lastIndexOf("}"));return codeout};
Threading.prototype.buildblob_from_function=function(function_in){var codeout=this.blobfixer("helper_functions");codeout+="\n"+this.blobfixer(function_in);return this.blobify(codeout)};
Threading.prototype.buildblob_from_class=function(){var myself=this;var proto=Object.getPrototypeOf(this);var methods=Object.getOwnPropertyNames(proto);var codeout="";for(var i=0;i<self.threadingjs.helpers.length;i++)codeout+="\n"+this.blobfixer(self.threadingjs.helpers[i]);codeout+="\n"+this.blobfixer("helper_functions");methods.forEach(function(name,fn){if(name=="constructor"||name=="main")return;codeout+="\n"+myself.buildFNinjector(myself[name])+"\n\n"});if("main"in myself)codeout+="\n"+this.blobfixer("main");
return this.blobify(codeout)};Threading.prototype.buildFNinjector=function(code){var code=code.toString();if(code.match(/^function/g)==null)code="function "+code;return code};self.threadingjs={};self.threadingjs.helpers=[];Worker.prototype={};Worker.prototype.id=null;Worker.prototype.anonMethodName=null;
Worker.prototype.sendToWorker=function(){anonMethodName=window[this.id]["anonMethodName"];callback_details=JSON.stringify({method:anonMethodName,args:Array.from(arguments)});window[this.id].postMessage(callback_details);return this};Worker.prototype.auto=function(func){this.onmessage=function(event){data=JSON.parse(event.data);if(data.method in window&&typeof window[data.method]==typeof function(){})window[data.method].apply(this,data.args)};return this};
